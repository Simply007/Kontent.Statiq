# Kontent.Statiq

![CI](https://github.com/alanta/Kontent.Statiq/workflows/CI/badge.svg?branch=master)

Module to retrieve content from [Kentico Kontent](https://kontent.ai) for building static websites with [Statiq](https://Statiq.dev).

## Getting started

* Setup a project on [Kontent](https://app.kontent.ai/sign-up), there's a free Starter-level account. 
  This document assumes you're using the [demo project](https://docs.kontent.ai/tutorials/set-up-kontent/projects/manage-projects#a-creating-a-sample-project).
* Get the API key for your project, you'll need it later
* Folow the [gettting started](https://statiq.dev/framework/) steps for Statiq.Framework, then come back here to setup a pipeline
* Add `Kontent.Statiq` to the project:

```dotnet add package Kontent.Statiq --version 1.0.0-*```

* For the pipeline, add the following code to your project:
```c#
public class Articles : Pipeline
{
    public Articles()
    {
        InputModules = new ModuleList{
            new Kontent.Statiq.Kontent("your-api-key") // put your API key here
                .WithContentType("article") // the code name for the content type
                .WithContentField("body_copy"), // the code name of the property containing the main content
            new SetDestination(Config.FromDocument((doc, ctx)  => new NormalizedPath( $"{doc["url_pattern"]}.html"))),
        };

        OutputModules = new ModuleList { 
            new WriteFiles()
        };
    }
}
```
* Run the console app: `dotnet run`

You should now see that for every Article in the Kontent site there's an html file in the `output` folder.

To configure the Kontent module for Statiq you need to specify the type of content to fetch by calling `.WithContentType("...")` and what property contains the main content by calling `.WithContentField("...")`. 
[Statiq Document](https://statiq.dev/framework/documents/) are essentially a set of key-value pairs and Kontent.Statiq will make all the properties on your content item available in the Statiq document.
You can access them using the code name for the property.

This is a very basic pipeline and gives you everything you need to get started with content served from a Kontent project. 
But Kontent has more advanced features and some nice extra's that you can leverage to get better integration and more robust code.

## Working with typed content

Working with code names to access content is very flexible but also a bit brittle. Fortunately, Kontent has full support for working with typed content and Kontent.Statiq allows you to use that within Statiq.
This means you can use regular Razor views with a strong typed model, without looking up content with magic strings.

The generator tool, [Kontent generator](https://github.com/Kentico/kontent-generators-net), generates a C# class for each of the content type in your project as well as a TypeProvider that maps type names to C# classes and vice versa.
This tool makes it easy to keep your code in sync with your Kontent project. It also provides all the code names for the properties on your content models so you can more easily work with untyped content in C#.

To make this work setup a Statiq project as described above and follow these additional steps:

* First, install the [Kontent generator](https://github.com/Kentico/kontent-generators-net) tool to generate strong-typed models for your project
* Generate the models for your project into the Models folder:

```cmd
KontentModelGenerator --projectid "your-api-key" --outputdir Models --namespace My.Models -s true -g true
```

* Put a Razor view named `Article.cs` into `/input`:

```cshtml
@model My.Models.Article

<h3>@Model.Title</h3>

@Model.BodyCopy
```

* Change the pipeline to look like this:

```c#
public class Posts : Pipeline
{
    public Posts()
    {
        InputModules = new ModuleList{
            new Kontent.Statiq.Kontent("your-api-key")
                .WithTypeProvider<My.Models.CustomTypeProvider>()
                .WithContentType(My.Models.Article.Codename)
                .WithContentField(My.Models.Article.BodyCopyCodename),
            new KontentAssetParser(),
            new SetDestination(Config.FromDocument((doc, ctx)  => new NormalizedPath( $"post/{doc[My.Models.Article.UrlPatternCodename]}.html"))),
        };

        ProcessModules = new ModuleList {
            new MergeContent(new ReadFiles(patterns: "Article.cshtml") ),
            new RenderRazor()
            .WithModel(Config.FromDocument((document, context) => document.AsKontent<My.Models.Article>())) // use the stront-typed model for Razor
        };

        OutputModules = new ModuleList { 
            new WriteFiles()
        };
    }
}
```
* Run the pipeline `dotnet run`

As you can see, all the magic strings are gone and the Razor view uses the model generated by Kontent. If you open the project in Visual Studio, you'll get code completion and feedback to help you write your view.

> _Note on Razor in Statiq_
>
> Razor rendering in Statiq supports the use of _Layout.cshtml and _ViewStart.cshtml to prevent repeating boilerplate html in each view. There is however currently [a bug](https://github.com/statiqdev/Statiq.Framework/issues/23) in Statiq.Framework that requires you to explicitly set the model 
> in the layout and viewstart razor files to the strong typed model.

## Inline content

Kontent allows you to have content within content. Which is very powerfull but requires a bit of work on the client side to make it work.
You basically have two options:

* _Inline resolvers_
  These are called by the Kontent Delivery Client to transform inline content items into HTML. They're nice for simple models with very basic HTML.
  Inline resolvers enable the Delivery API client to map structured content directly to HTML. This is achieved by making the property on the typed content class a string.
* _Structured content_
  You can also use the structured content in your application. This is achieved by making the content property of type `IRichTextContent`. This allows you to render the inline content in views or what ever code is appropriate.

Both these models can be used with Statiq, it's up to your preferences.

Where ever Statiq hands you a `Document`, use the extension method `.AsKontent<TModel>()` to get the typed model from the document.

## Working with Inline resolvers (optional)

_TODO_

## Working with Assets (optional)

_TODO_

## Troubleshooting

> There are weird object tags like this in my content: 

```xml
<object type="application/kenticocloud" data-type="item" data-rel="component" data-codename="n2ef9e997_4691_0118_8777_c0ac9cee683b"></object>
```

Make sure you read the section on structured content and follow the configuration steps.

## How do I build this repo?

You'll need a .NET Core development setup: Windows, Mac, Linux with VisualStudio, VS Code or Rider.

## Contribution guidelines

* You're welcome to send pull requests. Please create an issue first and include a unit test with your pull request to verify your code.
* Massive refactorings, code cleanups etc. will be rejected unless explictly agreed upon
* Adding additional Nuget package dependencies to the main assemblies is strongly discouraged

## Who do I talk to?

* Marnix van Valen on twitter : @marnixvanvalen or e-mail : marnix [at] alanta [dot] nl

## Blog posts & docs

[Static sites with Kentico Cloud, Statiq and Netlify](https://www.kenticotricks.com/blog/static-sites-with-kentico-cloud) Kristian Bortnik, 31 jan 2018
